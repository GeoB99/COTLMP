/*
 * PROJECT:     Cult of the Lamb Multiplayer Mod
 * LICENSE:     MIT (https://spdx.org/licenses/MIT)
 * PURPOSE:     Define COTLMP server class
 * COPYRIGHT:	Copyright 2025 Neco-Arc <neco-arc@inbox.ru>
 */

/* IMPORTS ********************************************************************/

using COTLMPServer.Messages;
using System;
using System.IO;
using System.Net;
using System.Net.Sockets;

/* CLASSES & CODE *************************************************************/

/**
 * @brief
 * Contains the classes/structs/enums for the server
 */
namespace COTLMPServer
{
    /**
     * @brief
     * This class implements the functionality of a server
     * 
     * @field Port
     * The port on which the server is running on
     * 
     * @field ServerStopped
     * The event that gets invoked when the server is stopped
     * 
     * @field _client
     * The UdpClient that the server listens with
     * 
     * @field disposedValue
     * If true, the server was disposed.
     * 
     * @field _logger
     * The logger provided by the owner of the instance
     * 
     * @field _reason
     * The reason that the server will be stopped for
     * 
     * @field _started
     * If true, the server was already started in this process
     */
    public sealed class Server : IDisposable
    {
        public readonly int Port;
        public event EventHandler<ServerStoppedArgs> ServerStopped;

        private UdpClient _client;
        private bool disposedValue;
        private ILogger _logger;
        private ServerStopReason _reason = ServerStopReason.NormalShutdown;
        private static bool _started = false;

        /**
         * @brief
         * The constructor for the Server class
         * 
         * @param[in] port
         * The port to bind (0 for any)
         * 
         * @param[in] logger
         * The logger class (can be null)
         * 
         * @throws SocketException
         * If UdpClient creation fails
         * 
         * @throws ArgumentOutOfRangeException
         * If UdpClient creation fails
         */
        private Server(int port, ILogger logger)
        {
            _logger = logger;
            _client = new UdpClient(port);
            StartRecieve();
            Port = ((IPEndPoint)_client.Client.LocalEndPoint).Port;
            _logger?.LogInfo("Server started!");
        }

        /**
         * @brief
         * A method that processes all packets that come into the server
         * 
         * @param[in] result
         * The result value generated by the client
         */
        private void PacketRecieve(IAsyncResult result)
        {
            if (disposedValue)
                return;

            IPEndPoint endpoint = null;
            byte[] recieved;
            try
            {
                recieved = _client.EndReceive(result, ref endpoint);
            }
            catch (SocketException e)
            {
                _logger?.LogFatal(e.Message);
                _reason = ServerStopReason.Error;
                Dispose(true);
                return;
            }
            catch (Exception e)
            {
                _logger?.LogFatal($"An unknown error happened while running the server: {e.Message}");
                _reason = ServerStopReason.Error;
                Dispose(true);
                return;
            }

            Message message;
            try
            {
                message = Message.Deserialize(recieved);
            }
            catch (InvalidDataException e)
            {
                _logger?.LogError($"Corrupt message recieved, error: {e.Message}");
                StartRecieve();
                return;
            }
            catch (ArgumentNullException e)
            {
                _logger?.LogError($"Corrupt message recieved, error: {e.Message}");
                StartRecieve();
                return;
            }

            switch (message.Type)
            {
                case MessageType.TeleportDungeon:
                    _logger?.LogInfo("Player has entered new dungeon, teleport all players!");
                    break;

                case MessageType.RitualPerform:
                    _logger?.LogInfo("Player is performing a ritual!");
                    break;

                case MessageType.PlayerJoin:
                    _logger?.LogInfo("Player has joined the server!");
                    break;

                case MessageType.PlayerLeft:
                    _logger?.LogInfo("Player has left the server!");
                    break;

                case MessageType.ChatNotify:
                    _logger?.LogInfo("Player has sent a chat message, broadcast it!");
                    break;
            }

            StartRecieve();
        }

        /**
         * @brief
         * A wrapper for _client.BeginRecieve()
         */
        private void StartRecieve()
        {
            if (disposedValue)
                return;
            _client.BeginReceive(PacketRecieve, null);
        }

        /**
         * @brief
         * Inner dispose method that actually disposes of resources
         * 
         * @param[in] disposing
         * Whether the dispose method was called manually or by the destructor
         */
        private void Dispose(bool disposing)
        {
            if (!disposedValue)
            {
                disposedValue = true;

                if (disposing)
                {
                    _client?.Dispose();
                    _logger?.LogInfo("Server stopped!");
                }
                _client = null;
                _logger = null;
                _started = false;
                ServerStopped?.Invoke(this, new ServerStoppedArgs(_reason));
            }
        }

        /**
         * @brief
         * Destructor that just calls the inner Dispose
         */
        ~Server()
        {
            Dispose(false);
        }

        /**
         * @brief
         * Dispose of the Server instance
         */
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /**
         * @brief
         * Creates a new instance of the class
         * 
         * @param[in] port
         * The port to bind the server to
         * 
         * @param[in] logger
         * The logger to use for the server
         * 
         * @returns
         * If the creation was successful, the instance of the class. Otherwise, null.
         */
        public static Server Start(int port = 0, ILogger logger = null)
        {
            if (_started) // make sure only one instance of the server can run in the process
                return null;
            _started = true;
            try
            {
                return new Server(port, logger);
            }
            catch (SocketException e)
            {
                logger?.LogFatal(e.Message);
                return null;
            }
            catch (ArgumentOutOfRangeException e)
            {
                logger?.LogFatal(e.Message);
                return null;
            }
            catch
            {
                return null;
            }
        }
    }
}

/* EOF */
